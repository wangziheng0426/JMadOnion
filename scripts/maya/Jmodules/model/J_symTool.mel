/////////////////////////////////////////////////////////////
///\file  J_symTool.mel
///\brief  检查对称工具
///
///\author 桔
///\version 1.0
///\date   16:38 2018/1/16
///History:  
///
///////////////////////////////////////////////////////////////


///模型对称检测 如果有对称部分会染色，再次运行取消染色
global proc J_symTool()//对称工具
{
string $nn[]=`ls -sl`;
select -cl;
if(size($nn))//判断是否运行过对称，运行过会把点颜色改回来
	{
		
		for($i in $nn)
		{
		if(`objectType $i`=="transform")
		{
			int $state=`getAttr ($i+".displayColors")`;
			if($state)
				{setAttr ($i+".displayColors") 0; polyColorPerVertex -rgb 0 0 0 $i;}
			else
				{
					RunSymTool($i);
				}
			}
		}
	}
}



global proc RunSymTool(string $sel)
{
int $PointCount[]=`polyEvaluate -v $sel`;
setAttr ($sel+".displayColors") 1;

int $PointLeft[];//左侧序号
vector $PointLeftV[];//左侧数据
int $Left;
int $PointRight[];//右侧序号
vector $PointRightV[];//右侧数据
int $Right;
for($i=0;$i<$PointCount[0];$i++)///区分x轴左右两侧
{
    vector $temp0=`xform -q -ws -t ($sel+".vtx["+$i+"]") `;
    //print $temp0;print "\n";
    if(($temp0.x)>0)
    {
        $PointRight[$Right]=$i;
        $PointRightV[$Right]=$temp0;
        $Right++;
    }
    else if(($temp0.x)<0)
    {
        $PointLeft[$Left]=$i;
        $PointLeftV[$Left]=$temp0;
        $Left++;
    }
    
}
//数据比对
//print $PointLeft;
int $count=0;
string $allLeft[];
string $allRight[];

for($i=0;$i<size($PointLeft);$i++)
{
    for($j=0;$j<size($PointRight);$j++)
    {
        vector $t0=($PointLeftV[$i]);
        vector $t1=($PointRightV[$j]);
        int $ax=(abs($t0.x)*1000);
        int $ay=(($t0.y)*1000);
        int $az=(($t0.z)*1000);
        //print ("aaa"+($sel+".vtx["+$PointLeft[$i]+"]")+$t0+" "+$az+"\n");
        
        int $bx=(($t1.x)*1000);
        int $by=(($t1.y)*1000);
        int $bz=(($t1.z)*1000);
        
        if($ax<$bx+1&&$ax>$bx-1 &&  $ay>$by-1 && $ay<$by+1 &&  $az>$bz-1&&$az<$bz+1)
		{
			polyColorPerVertex -rgb 1 0 0 ($sel+".vtx["+$PointLeft[$i]+"]") ;
			polyColorPerVertex -rgb 0 0 1 ($sel+".vtx["+$PointRight[$j]+"]") ;
			select -tgl ($sel+".vtx["+$PointLeft[$i]+"]");
			//print ($sel+".vtx["+$PointLeft[$i]+"]");print" \n";//
			break;
		}
		
		//print ($sel+".vtx["+$PointRight[$i]+"]");print" \n";
    }
    
}
};